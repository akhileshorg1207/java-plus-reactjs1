name: "DigiCert Scan (CodeQL + SBOM)"
description: "Runs CodeQL multi-language scan (languages auto from backend) and generates SBOM. Uploads artifacts for backend ingestion."
author: "DigiCert"

inputs:
  backend-env:
    description: "Backend environment to use (prod|stage)"
    required: false
    default: "prod"

  backend-api-key:
    description: "API key for DigiCert backend (pass via secrets)"
    required: true

  owner:
    description: "Repo owner/org. Default: github.repository_owner"
    required: false
    default: ""

  repo:
    description: "Repo name (without owner). Default: parsed from github.repository"
    required: false
    default: ""

  ref:
    description: "Git ref to resolve languages for (optional)."
    required: false
    default: ""

  languages:
    description: "Comma-separated CodeQL languages, or 'auto' to fetch from backend"
    required: false
    default: "auto"

  build-mode:
    description: "CodeQL build-mode (none, autobuild, manual)"
    required: false
    default: "none"

  sarif-output:
    description: "SARIF output file path"
    required: false
    default: "codeql.sarif"

  sarif-artifact-name:
    description: "Artifact name for SARIF upload"
    required: false
    default: "digicert_scan_results"

  upload-sarif-artifact:
    description: "Upload SARIF artifact (true/false)"
    required: false
    default: "true"

  post-sarif-to-backend:
    description: "POST SARIF result to backend API (true/false)"
    required: false
    default: "false"

  sarif-post-endpoint:
    description: "Backend endpoint path for SARIF ingestion (path only, appended to BACKEND_BASE_URL)"
    required: false
    default: "/releasemonitor/api/v1/gha/code-analysis/sarif"

  workflow-correlation-id:
    description: "Optional correlation id to group multi-language SARIF posts under the same workflow run"
    required: false
    default: ""

  scan-name:
    description: "Repo-scoped scan name used to create/find a DC One external release and dedupe scans by (scanName + branch + commitSha). When set, the action may skip if a scan already completed."
    required: false
    default: ""

  sarif-post-mode:
    description: "How to POST SARIF when multiple files exist: 'merged' (single call) or 'per-file' (one call per SARIF file)"
    required: false
    default: "merged"

  generate-sbom:
    description: "Generate SBOM using Trivy (true/false)"
    required: false
    default: "true"

  sbom-output:
    description: "SBOM output file path (CycloneDX JSON)"
    required: false
    default: "sbom.cyclonedx.json"

  sbom-artifact-name:
    description: "Artifact name for SBOM upload"
    required: false
    default: "sbom-cyclonedx"

runs:
  using: "composite"
  steps:
    - name: Resolve backend base URL
      shell: bash
      run: |
        set -euo pipefail
        case "${{ inputs.backend-env }}" in
          prod)
            echo "BACKEND_BASE_URL=__PROD_BASE_URL__" >> "$GITHUB_ENV"
            ;;
          stage)
            echo "BACKEND_BASE_URL=https://lucila-brashier-paxton.ngrok-free.dev" >> "$GITHUB_ENV"
            ;;
          *)
            echo "Unsupported backend-env: '${{ inputs.backend-env }}' (use prod|stage)" >&2
            exit 1
            ;;
        esac

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Resolve repo context (owner/repo/ref)
      shell: bash
      run: |
        set -euo pipefail

        OWNER_INPUT="${{ inputs.owner }}"
        REPO_INPUT="${{ inputs.repo }}"
        REF_INPUT="${{ inputs.ref }}"

        if [ -z "$OWNER_INPUT" ]; then
          OWNER_INPUT="${GITHUB_REPOSITORY_OWNER:-}"
        fi

        if [ -z "$REPO_INPUT" ]; then
          # GITHUB_REPOSITORY = owner/repo
          REPO_INPUT="${GITHUB_REPOSITORY#*/}"
        fi

        if [ -z "$OWNER_INPUT" ] || [ -z "$REPO_INPUT" ] || [ "$REPO_INPUT" = "$GITHUB_REPOSITORY" ]; then
          echo "Could not resolve owner/repo from GitHub context. Pass inputs.owner and inputs.repo explicitly." >&2
          exit 1
        fi

        if [ -z "$REF_INPUT" ]; then
          REF_INPUT="${GITHUB_REF}"
        fi

        echo "DC_OWNER=$OWNER_INPUT" >> "$GITHUB_ENV"
        echo "DC_REPO=$REPO_INPUT" >> "$GITHUB_ENV"
        echo "DC_REF=$REF_INPUT" >> "$GITHUB_ENV"

        # Default: run the scan unless backend prepare says otherwise.
        echo "DC_SHOULD_RUN=true" >> "$GITHUB_ENV"

    - name: Prepare Code Analysis Scan (scan-name)
      if: ${{ inputs.post-sarif-to-backend == 'true' && inputs.scan-name != '' }}
      id: cas_prepare
      shell: bash
      run: |
        set -euo pipefail

        URL="${BACKEND_BASE_URL}/releasemonitor/api/v1/gha/code-analysis/scans/prepare"
        echo "Preparing CAS at: $URL"

        REPO_FULL_NAME="${GITHUB_REPOSITORY:-${DC_OWNER}/${DC_REPO}}"
        REF_NAME="${GITHUB_REF_NAME:-}"

        payload_file="$(mktemp)"
        jq -n \
          --arg scanName "${{ inputs.scan-name }}" \
          --arg repository "$REPO_FULL_NAME" \
          --arg owner "${DC_OWNER}" \
          --arg repo "${DC_REPO}" \
          --arg ref "${GITHUB_REF:-${DC_REF}}" \
          --arg refName "$REF_NAME" \
          --arg sha "${GITHUB_SHA:-}" \
          --arg runId "${GITHUB_RUN_ID:-}" \
          --arg runAttempt "${GITHUB_RUN_ATTEMPT:-}" \
          ' {
              scanName: $scanName,
              github: {
                repository: $repository,
                owner: $owner,
                repo: $repo,
                ref: $ref,
                refName: $refName,
                sha: $sha,
                runId: $runId,
                runAttempt: $runAttempt
              }
            } ' > "$payload_file"

        raw="$(curl -sS -X POST "$URL" \
          -H "Content-Type: application/json" \
          -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
          --data-binary @"$payload_file" \
          -w $'\n%{http_code}')"

        rm -f "$payload_file"

        body="${raw%$'\n'*}"
        status="${raw##*$'\n'}"

        if [ -z "$status" ] || ! [[ "$status" =~ ^[0-9][0-9][0-9]$ ]]; then
          echo "Failed to prepare CAS (no HTTP status). Response: $raw" >&2
          exit 1
        fi

        if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
          echo "Failed to prepare CAS (HTTP $status). Response body: $body" >&2
          exit 1
        fi

        CAS_ID="$(echo "$body" | jq -r '.id // empty')"
        SHOULD_RUN="$(echo "$body" | jq -r '.shouldRun // empty')"

        if [ -z "$CAS_ID" ]; then
          echo "Backend did not return CAS id. Response body: $body" >&2
          exit 1
        fi

        if [ -z "$SHOULD_RUN" ]; then
          echo "Backend did not return shouldRun. Response body: $body" >&2
          exit 1
        fi

        echo "DC_CAS_ID=$CAS_ID" >> "$GITHUB_ENV"
        echo "DC_SHOULD_RUN=$SHOULD_RUN" >> "$GITHUB_ENV"

        echo "id=$CAS_ID" >> "$GITHUB_OUTPUT"
        echo "shouldRun=$SHOULD_RUN" >> "$GITHUB_OUTPUT"

        if [ "$SHOULD_RUN" != "true" ]; then
          echo "Scan already completed or in progress; skipping (shouldRun=$SHOULD_RUN)."
        fi

    - name: Create Code Analysis Scan (CAS) on backend
      if: ${{ inputs.post-sarif-to-backend == 'true' && inputs.scan-name == '' }}
      id: cas
      shell: bash
      run: |
        set -euo pipefail

        URL="${BACKEND_BASE_URL}/releasemonitor/api/v1/gha/code-analysis/scans"
        echo "Creating CAS at: $URL"

        REPO_FULL_NAME="${GITHUB_REPOSITORY:-${DC_OWNER}/${DC_REPO}}"
        REF_NAME="${GITHUB_REF_NAME:-}"

        payload_file="$(mktemp)"
        jq -n \
          --arg repository "$REPO_FULL_NAME" \
          --arg owner "${DC_OWNER}" \
          --arg repo "${DC_REPO}" \
          --arg ref "${GITHUB_REF:-${DC_REF}}" \
          --arg refName "$REF_NAME" \
          --arg sha "${GITHUB_SHA:-}" \
          --arg runId "${GITHUB_RUN_ID:-}" \
          --arg runAttempt "${GITHUB_RUN_ATTEMPT:-}" \
          ' {
              github: {
                repository: $repository,
                owner: $owner,
                repo: $repo,
                ref: $ref,
                refName: $refName,
                sha: $sha,
                runId: $runId,
                runAttempt: $runAttempt
              }
            } ' > "$payload_file"

        raw="$(curl -sS -X POST "$URL" \
          -H "Content-Type: application/json" \
          -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
          --data-binary @"$payload_file" \
          -w $'\n%{http_code}')"

        rm -f "$payload_file"

        body="${raw%$'\n'*}"
        status="${raw##*$'\n'}"

        if [ -z "$status" ] || ! [[ "$status" =~ ^[0-9][0-9][0-9]$ ]]; then
          echo "Failed to create CAS (no HTTP status). Response: $raw" >&2
          exit 1
        fi

        if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
          echo "Failed to create CAS (HTTP $status). Response body: $body" >&2
          exit 1
        fi

        CAS_ID="$(echo "$body" | jq -r '.id // empty')"
        if [ -z "$CAS_ID" ]; then
          echo "Backend did not return CAS id. Response body: $body" >&2
          exit 1
        fi

        echo "DC_CAS_ID=$CAS_ID" >> "$GITHUB_ENV"
        echo "id=$CAS_ID" >> "$GITHUB_OUTPUT"

    - name: Resolve CodeQL languages
      id: langs
      shell: bash
      if: ${{ env.DC_SHOULD_RUN == 'true' }}
      run: |
        set -euo pipefail

        if [ "${{ inputs.languages }}" != "auto" ]; then
          # normalize commas/spaces
          LANGS="$(echo "${{ inputs.languages }}" | tr -d ' ' )"
          echo "LANGS=$LANGS" >> "$GITHUB_ENV"
          echo "languages=$LANGS" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        URL="${BACKEND_BASE_URL}/releasemonitor/api/v1/gha/code-analysis/languages"
        echo "Fetching languages from: $URL"

        # Requires jq on runner (ubuntu has it)
        # Capture body + status code to handle API errors gracefully.
        if [ -n "${DC_REF}" ]; then
          RAW="$(curl -sS -G "$URL" \
            -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
            --data-urlencode "repo=${DC_REPO}" \
            --data-urlencode "ref=${DC_REF}" \
            -w $'\n%{http_code}')"
        else
          RAW="$(curl -sS -G "$URL" \
            -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
            --data-urlencode "repo=${DC_REPO}" \
            -w $'\n%{http_code}')"
        fi

        BODY="${RAW%$'\n'*}"
        STATUS="${RAW##*$'\n'}"

        if [ -z "$STATUS" ] || ! [[ "$STATUS" =~ ^[0-9][0-9][0-9]$ ]]; then
          echo "Failed to call backend (no HTTP status). Response: $RAW" >&2
          exit 1
        fi

        if [ "$STATUS" -lt 200 ] || [ "$STATUS" -ge 300 ]; then
          ERR_MSG="$(echo "$BODY" | jq -r '.error.message? // .error? // .message? // empty' 2>/dev/null || true)"
          if [ -z "$ERR_MSG" ]; then
            ERR_MSG="Backend returned HTTP $STATUS"
          fi
          echo "Failed to fetch languages: $ERR_MSG" >&2
          echo "Backend response body: $BODY" >&2
          exit 1
        fi

        echo "Backend response: $BODY"

        LANGS="$(echo "$BODY" | jq -e -r '.languages | select(type=="array") | join(",")' 2>/dev/null || true)"

        if [ -z "$LANGS" ] || [ "$LANGS" = "null" ]; then
          echo "No languages returned by backend." >&2
          echo "Backend response body: $BODY" >&2
          exit 1
        fi

        echo "LANGS=$LANGS" >> "$GITHUB_ENV"
        echo "languages=$LANGS" >> "$GITHUB_OUTPUT"

    - name: Initialize CodeQL
      if: ${{ env.DC_SHOULD_RUN == 'true' }}
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ steps.langs.outputs.languages }}
        build-mode: ${{ inputs.build-mode }}

    - name: Perform CodeQL Analysis
      if: ${{ env.DC_SHOULD_RUN == 'true' }}
      uses: github/codeql-action/analyze@v3
      with:
        upload: false
        output: ${{ inputs.sarif-output }}

    - name: Post SARIF to backend
      if: ${{ inputs.post-sarif-to-backend == 'true' && env.DC_SHOULD_RUN == 'true' }}
      shell: bash
      run: |
        set -euo pipefail

        SARIF_PATH="${{ inputs.sarif-output }}"
        SARIF_FILES=()

        if [ -f "$SARIF_PATH" ]; then
          SARIF_FILES+=("$SARIF_PATH")
        elif [ -d "$SARIF_PATH" ]; then
          while IFS= read -r f; do
            SARIF_FILES+=("$f")
          done < <(find "$SARIF_PATH" -type f -name "*.sarif" | sort)
        else
          # Fallback: locate SARIF files in workspace (CodeQL may write to a different path)
          while IFS= read -r f; do
            SARIF_FILES+=("$f")
          done < <(find . -type f -name "*.sarif" \
            -not -path "./.git/*" \
            -not -path "./node_modules/*" \
            | sort)
        fi

        if [ "${#SARIF_FILES[@]}" -eq 0 ]; then
          echo "No SARIF files found. Expected at '${SARIF_PATH}' (file or directory)." >&2
          exit 1
        fi

        POST_MODE_RAW="${{ inputs.sarif-post-mode }}"
        POST_MODE="$(echo "$POST_MODE_RAW" | tr '[:upper:]' '[:lower:]' | tr -d ' ')"
        if [ "$POST_MODE" != "merged" ] && [ "$POST_MODE" != "per-file" ]; then
          echo "Invalid sarif-post-mode: '$POST_MODE_RAW' (use 'merged' or 'per-file')" >&2
          exit 1
        fi

        ENDPOINT_PATH="${{ inputs.sarif-post-endpoint }}"
        if [ -z "$ENDPOINT_PATH" ] || [[ "$ENDPOINT_PATH" != /* ]]; then
          echo "sarif-post-endpoint must be a non-empty absolute path starting with '/'" >&2
          exit 1
        fi

        URL="${BACKEND_BASE_URL}${ENDPOINT_PATH}"

        CORRELATION_ID_INPUT="${{ inputs.workflow-correlation-id }}"
        if [ -n "$CORRELATION_ID_INPUT" ]; then
          CORRELATION_ID="$CORRELATION_ID_INPUT"
        elif [ -n "${DC_CAS_ID:-}" ]; then
          CORRELATION_ID="$DC_CAS_ID"
        else
          CORRELATION_ID="gha:${GITHUB_RUN_ID}:${GITHUB_RUN_ATTEMPT}:${GITHUB_REPOSITORY}:${GITHUB_SHA}"
        fi

        REPO_FULL_NAME="${GITHUB_REPOSITORY:-${DC_OWNER}/${DC_REPO}}"
        REF_NAME="${GITHUB_REF_NAME:-}"

        # For best per-language behavior, run this composite action once per language (matrix)
        # and set inputs.languages to a single language and inputs.sarif-output to a language-specific file.
        LANGS_RAW="${{ steps.langs.outputs.languages }}"
        LANGS_CSV="$(echo "$LANGS_RAW" | tr -d ' ' || true)"
        if [ -z "$LANGS_CSV" ]; then
          LANGS_CSV="auto"
        fi

        echo "Found ${#SARIF_FILES[@]} SARIF file(s). Post mode: $POST_MODE"

        post_one() {
          local sarif_file="$1"
          local sarif_file_name="$2"

          local payload_file
          payload_file="$(mktemp)"

          jq -n \
            --slurpfile sarif "$sarif_file" \
            --arg correlationId "$CORRELATION_ID" \
            --arg owner "${DC_OWNER}" \
            --arg repo "${DC_REPO}" \
            --arg repository "$REPO_FULL_NAME" \
            --arg ref "${GITHUB_REF:-${DC_REF}}" \
            --arg refName "$REF_NAME" \
            --arg sha "${GITHUB_SHA:-}" \
            --arg workflow "${GITHUB_WORKFLOW:-}" \
            --arg workflowRef "${GITHUB_WORKFLOW_REF:-}" \
            --arg job "${GITHUB_JOB:-}" \
            --arg runId "${GITHUB_RUN_ID:-}" \
            --arg runAttempt "${GITHUB_RUN_ATTEMPT:-}" \
            --arg eventName "${GITHUB_EVENT_NAME:-}" \
            --arg languages "$LANGS_CSV" \
            --arg sarifFileName "$sarif_file_name" \
            '{
              correlationId: $correlationId,
              github: {
                repository: $repository,
                owner: $owner,
                repo: $repo,
                ref: $ref,
                refName: $refName,
                sha: $sha,
                eventName: $eventName,
                workflow: $workflow,
                workflowRef: $workflowRef,
                job: $job,
                runId: $runId,
                runAttempt: $runAttempt
              },
              codeql: {
                languages: ($languages | split(",") | map(select(length > 0)))
              },
              sarifFileName: $sarifFileName,
              sarif: $sarif[0]
            }' > "$payload_file"

          echo "Posting SARIF to: $URL"

          local raw body status
          raw="$(curl -sS -X POST "$URL" \
            -H "Content-Type: application/json" \
            -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
            --data-binary @"$payload_file" \
            -w $'\n%{http_code}')"

          rm -f "$payload_file"

          body="${raw%$'\n'*}"
          status="${raw##*$'\n'}"

          if [ -z "$status" ] || ! [[ "$status" =~ ^[0-9][0-9][0-9]$ ]]; then
            echo "Failed to post SARIF (no HTTP status). Response: $raw" >&2
            exit 1
          fi

          if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
            echo "Failed to post SARIF for '$sarif_file_name' (HTTP $status). Response body: $body" >&2
            exit 1
          fi

          echo "Posted SARIF '$sarif_file_name' successfully (HTTP $status)"
        }

        if [ "$POST_MODE" = "merged" ]; then
          MERGED_SARIF_FILE="$(mktemp)"
          # Merge SARIF files by concatenating runs; keep top-level fields from the first file.
          jq -s '
            def safeRuns: (.runs // []);
            (.[0] // {}) as $base
            | ($base | del(.runs))
            + { runs: ([ .[] | safeRuns[] ] ) }
          ' "${SARIF_FILES[@]}" > "$MERGED_SARIF_FILE"

          echo "Posting merged SARIF (runs from ${#SARIF_FILES[@]} file(s))"
          post_one "$MERGED_SARIF_FILE" "merged.sarif"
          rm -f "$MERGED_SARIF_FILE"
        else
          for SARIF_FILE in "${SARIF_FILES[@]}"; do
            SARIF_BASENAME="$(basename "$SARIF_FILE")"
            echo "Posting SARIF file: $SARIF_FILE"
            post_one "$SARIF_FILE" "$SARIF_BASENAME"
          done
        fi

    - name: Finalize CAS on backend
      if: ${{ always() && inputs.post-sarif-to-backend == 'true' && env.DC_SHOULD_RUN == 'true' }}
      continue-on-error: true
      shell: bash
      run: |
        set -euo pipefail

        if [ -z "${DC_CAS_ID:-}" ]; then
          echo "No DC_CAS_ID set; skipping finalize."
          exit 0
        fi

        JOB_STATUS="${{ job.status }}"
        if [ "$JOB_STATUS" = "success" ]; then
          FINAL_STATUS="COMPLETED"
        else
          FINAL_STATUS="FAILED"
        fi

        URL="${BACKEND_BASE_URL}/releasemonitor/api/v1/gha/code-analysis/scans/${DC_CAS_ID}/finalize"
        echo "Finalizing CAS ${DC_CAS_ID} at: $URL (status=${FINAL_STATUS}, job.status=${JOB_STATUS})"

        payload_file="$(mktemp)"
        jq -n \
          --arg status "$FINAL_STATUS" \
          --arg message "Composite action finalized with job.status=${JOB_STATUS}" \
          --arg failureStage "composite" \
          '{ status: $status, message: $message, failureStage: $failureStage }' > "$payload_file"

        raw="$(curl -sS -X POST "$URL" \
          -H "Content-Type: application/json" \
          -H "X-API-KEY: ${{ inputs.backend-api-key }}" \
          --data-binary @"$payload_file" \
          -w $'\n%{http_code}')"

        rm -f "$payload_file"

        body="${raw%$'\n'*}"
        status="${raw##*$'\n'}"

        if [ -z "$status" ] || ! [[ "$status" =~ ^[0-9][0-9][0-9]$ ]]; then
          echo "Finalize CAS failed (no HTTP status). Response: $raw" >&2
          exit 0
        fi

        if [ "$status" -lt 200 ] || [ "$status" -ge 300 ]; then
          echo "Finalize CAS failed (HTTP $status). Response body: $body" >&2
          exit 0
        fi

        echo "Finalize CAS succeeded (HTTP $status)"

    - name: Upload SARIF result as artifact
      if: ${{ inputs.upload-sarif-artifact == 'true' && env.DC_SHOULD_RUN == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.sarif-artifact-name }}
        path: ${{ inputs.sarif-output }}

    - name: Generate SBOM (Trivy CycloneDX)
      if: ${{ inputs.generate-sbom == 'true' && env.DC_SHOULD_RUN == 'true' }}
      uses: aquasecurity/trivy-action@0.33.1
      with:
        scan-type: "fs"
        format: "cyclonedx"
        output: ${{ inputs.sbom-output }}

    - name: Upload SBOM as artifact
      if: ${{ inputs.generate-sbom == 'true' && env.DC_SHOULD_RUN == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.sbom-artifact-name }}
        path: ${{ inputs.sbom-output }}
